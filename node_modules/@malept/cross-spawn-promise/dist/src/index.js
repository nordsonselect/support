"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cross_spawn_1 = __importDefault(require("cross-spawn"));
function stringifyCommand(cmd, args) {
    if (args && Array.isArray(args) && args.length > 0) {
        return `${cmd} ${args.join(" ")}`;
    }
    else {
        return cmd;
    }
}
class CrossSpawnError extends Error {
    constructor(cmd, args, originalError, stderr) {
        const fullCommand = stringifyCommand(cmd, args);
        const errorMessage = originalError.message || originalError;
        super(`Error executing command (${fullCommand}):\n${errorMessage}\n${stderr}`.trim());
        this.originalError = originalError;
    }
}
exports.CrossSpawnError = CrossSpawnError;
class ExitCodeError extends Error {
    constructor(cmd, args, code, stdout, stderr) {
        const fullCommand = stringifyCommand(cmd, args);
        super(`Command failed with a non-zero return code (${code}):\n${fullCommand}\n${stdout}\n${stderr}`.trim());
        this.cmd = cmd;
        this.args = args;
        this.code = code;
        this.stdout = stdout;
        this.stderr = stderr;
    }
}
exports.ExitCodeError = ExitCodeError;
/**
 * A wrapper around `cross-spawn`'s `spawn` function which can optionally log the command executed
 * and/or change the error object via a callback.
 */
async function spawn(cmd, args, options) {
    if (!options) {
        options = {};
    }
    const { logger, updateErrorCallback, ...spawnOptions } = options;
    if (logger)
        logger(`Executing command ${stringifyCommand(cmd, args)}`);
    return new Promise((resolve, reject) => {
        let stdout = "";
        let stderr = "";
        const process = cross_spawn_1.default(cmd, args, spawnOptions);
        if (process.stdout) {
            process.stdout.on("data", data => {
                stdout += data.toString();
            });
        }
        if (process.stderr) {
            process.stderr.on("data", 
            /* istanbul ignore next */ data => {
                stderr += data.toString();
            });
        }
        process.on("close", code => {
            if (code === 0) {
                resolve(stdout);
            }
            else {
                reject(new ExitCodeError(cmd, args, code, stdout, stderr));
            }
        });
        process.on("error", err => {
            if (updateErrorCallback) {
                updateErrorCallback(err, !!logger);
            }
            reject(new CrossSpawnError(cmd, args, err, stderr));
        });
    });
}
exports.spawn = spawn;
//# sourceMappingURL=index.js.map